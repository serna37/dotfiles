#*cpp.algorithm.snippets*        Version 1.0
#==============================================================================
#CONTENTS                                                 *cpp.algorithm*
#
#    Brute Force .................... |brute force|
#    Binary Search  ................. |binary search|
#    Range .......................... |sequence range algorithm|
#    Sequence ....................... |sequence, others algorithm|
#    Fenwick ........................ |fenwick tree|
#    BFS ............................ |BFS, grid|
#    DFS ............................ |DFS, tree|
#    DP ............................. |DP transition|
#    Food for thought  .............. |Food for thought|
#
#==============================================================================

# =========================================================
# Brute Force
# =========================================================
snippet algo_brute_permutation "next permutation" b
// =========================
// é †åˆ—å…¨æ¢ç´¢
// O(N!) N < 12ç¨‹åº¦
// 1 2 3,  1 3 2,  2 1 3,  2 3 1,  ...
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
// â­ï¸ ã‚½ãƒ¼ãƒˆã¯ã—ã¾ã—ãŸã‹ï¼Ÿ
endsnippet
snippet algo_brute_permutation_dfs_seq "DFSé‡è¤‡é †åˆ—åˆ—æŒ™" b
// =========================
// é †åˆ—å…¨æ¢ç´¢ DFSã§é‡è¤‡é †åˆ—åˆ—æŒ™
// å˜èª¿å¢—åŠ ãªã‚‰O(N+M-1 choose M-1) ç›®å®‰    N < 10ç¨‹åº¦(ã‚‚ã†ã¡ã‚‡ã„ã„ã‘ã‚‹ã‹ã‚‚)
// $4 ~ $5 ã¾ã§ã®æ•°ã§ã€è¦ç´ æ•°${1:N}ã®æ•°åˆ—ã‚’é †åˆ—å…¨æ¢ç´¢
vector<int> ${2:perm}($1);
auto ${3:dfs} = [&](auto &f, int mi, int mx, int last = 0) -> void {
	if (last == $1) {
		// ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
		// å‰å‘¨ã¾ã§ã§$1-1è¦ç´ ã¤ãã£ãŸã€ä»Š=$1ã®ã¨ãçµ‚äº†
		${6:some}
		return;
	}
	for (int i = mi; i <= mx; ++i) {
		$2[last] = i;
		// ç‹­ç¾©å˜èª¿å¢—åŠ ã®å ´åˆ
		// 1 2 3 4 5
		// mi = i + 1;
		//
		// åºƒç¾©å˜èª¿å¢—åŠ ã®å ´åˆ
		// 1 1 2 3 4 è¢«ã‚Šok
		// mi = i;
		f(f, mi, mx, last + 1);
	}
};
$3($3, ${4:1}, ${5:M});
endsnippet
snippet algo_brute_bit_loop "bit loop" b
// =========================
// bitå…¨æ¢ç´¢
// O(2^N) N < 25ç¨‹åº¦
for (${1:long long} ${2:bit} = 0; $2 < (${3:1ll} << ${4:N}); ++$2) {
	${5:long long} tmp = 0;
	for (int k = 0; k < $4; ++k) {
		// kç•ªç›®ã‚’ä½¿ã†ã‹ã©ã†ã‹
		if ($2 & ($3 << k)) {
			// bit = 11001 ã®ã¨ã
			// kã¯   01  4 ãŒé¸ã°ã‚Œã‚‹
			tmp |= ${6:A}[k];
		}
	}
}
endsnippet
snippet algo_brute_bit_loop_2 "bit loop" b
// =========================
// bitå…¨æ¢ç´¢ 2é‡
// O(2^N) N < 12ç¨‹åº¦
for (int bit = 0; bit < (1 << ${1:H}); ++bit) {
	for (int bit2 = 0; bit2 < (1 << ${2:W}); ++bit2) {
		vector<int> ${3:h}, ${4:w};
		for (int k = 0; k < $1; ++k) {
			// $1å´ã®
			// kç•ªç›®ã‚’ä½¿ã†å ´åˆã€ã“ã®é…åˆ—ã«idxå…¥ã‚Œã¦ã‚‹
			if (bit & (1 << k)) $3.push_back(k);
		}
		//
		for (int k = 0; k < $2; ++k) {
			// $2å´ã®
			// kç•ªç›®ã‚’ä½¿ã†å ´åˆã€ã“ã®é…åˆ—ã«idxå…¥ã‚Œã¦ã‚‹
			if (bit2 & (1 << k)) $4.push_back(k);
		}
		//
		// bit = 1100
		// bit2= 1000 ã®ã¨ã
		// h = {0, 1} è¡Œç›®ã¨
		// w = {0} åˆ—ç›®ãŒé¸ã°ã‚Œã¦ã„ã‚‹
	}
}
endsnippet
snippet algo_brute_bit_n_order "bit N" b
// =========================
// bitå…¨æ¢ç´¢ éå†å¸° é‡è¤‡é †åˆ—åˆ—æŒ™ O($2^$1) N < 10ç¨‹åº¦
// ${1:N}æ¡ ${2:K}é€²æ•°
vector<int> bit($1, 0);
// bit = {0,0,0}, {0,0,1}, {0,1,0}, {0,1,1} ...
while (1) {
	// bit = {1,1,0} ã‚’å·¦ã‹ã‚‰è¦‹ã‚‹ãƒ«ãƒ¼ãƒ—
	for (int i = 0; i < $1; ++i) {
		int tmp = bit[i]; // iæ¡ç›®ã®æ•°å­—ï¼ˆ$2é€²æ³•ï¼‰
	}
	// ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
	int order = $1 - 1, stop = 0;
	while (1) {
		++bit[order]; // ä¸‹1æ¡ç›®ã‹ã‚‰å¢—ã‚„ã™
		if (bit[order] < $2) break; // ãã‚Šã‚ã’çµ‚äº†
		//
		// æœ€å¤§æ¡ãŒæº¢ã‚ŒãŸã‚‰å…¨ä½“whileã‚’çµ‚äº†
		if (order == 0) {
			stop = 1;
			break; 
		}
		//
		// ç¹°ã‚Šä¸Šã’ã‚‹ã®ã§ä»Šã®æ¡ã¯0ã€æ¬¡ã®æ¡ã«è¡Œã
		bit[order--] = 0;
	}
	if (stop) break;
}
endsnippet
# TODO bitæ¼”ç®—ç³»ã¨ã—ã¦ã¾ã¨ã‚ç›´ã—ãŸã„
snippet algo_brute_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet

# =========================================================
# Binary Search
# =========================================================
snippet algo_bisearch "bisearch" b
// =========================
// ã«ã¶ãŸã‚“ O(logN)
auto ${1:test} = [&](${2:long long} x) -> bool {
	// oã«ãªã‚‹æ¡ä»¶ã‚’è¨˜è¿°
	// x x x o o o o
	//       â†‘ã“ã“ã‚’æ±‚ã‚ã‚‹
	${3:return x >= K}
};
// $4: ãƒ€ãƒ¡ãªå·¦å´    $5: æº€ãŸã™å³å´
$2 ${4:L} = 0, ${5:R} = 1, ${6:MID} = 0;
while (!$1($5)) $5 <<= 1; // æŒ‡æ•°æ¢ç´¢
while (abs($5 - $4) > 1) ($1($6 = $4 + ($5 - $4) / 2) ? $5 : $4) = $6;
cout << $5 << endl;
endsnippet
snippet algo_bisearch_real_numbers "bisearch Real Number" b
// =========================
// å®Ÿæ•°ã«ã¶ãŸã‚“ O(logN)
auto ${1:test} = [&](${2:double} x) -> bool {
	// oã«ãªã‚‹æ¡ä»¶ã‚’è¨˜è¿°
	// x x x o o o o
	//       â†‘ã“ã“ã‚’æ±‚ã‚ã‚‹
	${3:return x >= K}
};
// $4: ãƒ€ãƒ¡ãªå·¦å´    $5: æº€ãŸã™å³å´
$2 ${4:L} = 0, ${5:R} = 1, ${6:MID} = 0;
while (!$1($5)) $5 *= 2; // æŒ‡æ•°æ¢ç´¢
while (abs($5 - $4) > EPS and abs($5 - $4) / max($5, $4) > EPS)
	($1($6 = $4 + ($5 - $4) / 2) ? $5 : $4) = $6;
cout << $5 << endl;
endsnippet
snippet algo_bisearch_ika_cnt_idx "ä»¥ä¸‹ã®å€‹æ•°" b
// =========================
// $3ã®ã†ã¡ã€$4ä»¥ä¸‹ã®å€‹æ•°  =  $4ã‚ˆã‚Šå¤§ãã„æœ€å·¦ã®idx
//          â†“8ã®å ´åˆ
// 0 1 2 3 4  5
// 1 2 2 3 4  21 22 23 23
// <------->|                  id:4, cnt:5
${1:int} ${2:cnt} = upper_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bisearch_sita_cnt_idx "ã‚ˆã‚Šä¸‹ã®å€‹æ•°" b
// =========================
// $3ã®ã†ã¡ã€$4ã‚ˆã‚Šä¸‹ã®å€‹æ•°  =  $4ä»¥ä¸Šæœ€å·¦ã®idx
//         â†“4ã®å ´åˆ
// 0 1 2 3 4
// 1 2 2 3 4 21 22 23 23
// <---->|                     id:3, cnt:4
${1:int} ${2:cnt} = lower_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bisearch_izyou_cnt "ä»¥ä¸Šã®å€‹æ•°" b
// =========================
// 1 2 2 3 4 21 22 23 23
//         4
//         |<---------->
// $3ã®ã†ã¡ã€$4ä»¥ä¸Šã®å€‹æ•°
${1:int} ${2:cnt} = ${3:A}.end() - lower_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bisearch_ue_cnt "ã‚ˆã‚Šä¸Šã®å€‹æ•°" b
// =========================
// 1 2 2 3 4 21 22 23 23
//         4 |
//           |<-------->
// $3ã®ã†ã¡ã€$4ã‚ˆã‚Šå¤§ãã„å€‹æ•°
${1:int} ${2:cnt} = ${3:A}.end() - upper_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bisearch_ika_max "0, lim]" b
// =========================
// 1 2 2 3 4 21 22 23 23
//         4
// ------->o
// $2ä»¥ä¸‹ã®æœ€å³
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bisearch_sita_max "0, lim)" b
// =========================
// 1 2 2 3 4 21 22 23 23
//       | 4
// ----->o
// $2ã‚ˆã‚Šä¸‹ã®æœ€å³
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bisearch_izyou_min "[lim, N" b
// =========================
// 1 2 2 3 4 21 22 23 23
//         4
//         o<-----
// $2ä»¥ä¸Šã®æœ€å·¦
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet
snippet algo_bisearch_ue_min "(lim, N" b
// =========================
// 1 2 2 3 4 21 22 23 23
//         4 |
//           o<-----
// $2ã‚ˆã‚Šå¤§ãã„æœ€å·¦
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet

# =========================================================
# Range
# =========================================================
snippet algo_range_syakutori "å°ºå–æ³•" b
// =========================
// å°ºå–æ³• O(N)
// é€£ç¶šã®å’ŒãŒ$4ä»¥ä¸‹ã§ã‚ã‚‹ã€æœ€å¤§é•·ã‚’æ±‚ã‚ã‚‹
// 1. lã‚’å›ºå®šã—ã€ã§ãã‚‹ã ã‘rã‚’å¢—ã‚„ã™
// 2. åŒºé–“ã‚’ã²ã¨ã¤å³ã«ã€‚å’Œã®åŒºé–“ã‹ã‚‰å·¦ç«¯ãŒæŠœã‘ã‚‹
// 3. åŒºé–“ã®å€‹æ•°ã¯r-lå€‹
for (int l = 0, r = 0, ${1:sum} = 0; l < ${2:N}; $1 -= ${3:A}[l++]) {
	// 2, 3, 1, 4, 5, 8, 6, 7
	//    l     r  å’ŒãŒ7ã¾ã§rã‚’ãšã‚‰ã™
	//    <----->  é•·ã•3
	while (r < $2 and $1 + $3[r] <= ${4:K}) {
		$1 += $3[r++];
	}
	${5:ans} += r - l;
}
endsnippet
snippet algo_range_zeta "ç´¯ç©å’Œ" b
// =========================
// ç´¯ç©å’Œ   å·¦ã‹ã‚‰iå€‹ã¶ã‚“ã®å’Œ   S_i = Î£ A_0ã€œA_i-1
// Î£[l, r) = S[r] - S[l]
vector<${1:long long}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; ++i) {
	$2[i + 1] = $2[i] + ${4:A}[i];
	// 0-1, 2-3, .... 2é …å·®ã®ç´¯ç©å’Œ
	// $2[i + 1] = $2[i];
	// if (i & 1) $2[i + 1] += $4[i] - $4[i - 1];
}
endsnippet
snippet algo_range_zeta_rev "ruisekiwa reverse" b
// =========================
// åè»¢ç´¯ç©å’Œ   Aiã‹ã‚‰å³å…¨éƒ¨ã®å’Œ   R_i = Î£ A_n-iã€œA_last
vector<${1:long long}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; --i) {
	$2[i] = $2[i + 1] + ${4:A}[i];
	// 2é …å·®ã®ç´¯ç©å’Œ(å³ç«¯ã‹ã‚‰) ..., N-4 - N-3, N-2 - N-1
	// $2[i] = $2[i + 1];
	// if (i & 1) $2[i] += $4[i + 1] - $4[i];
}
// ä¸¡ç«¯ç´¯ç©å’Œã®åˆæˆæ³•
// Î£ å·¦ã‹ã‚‰Ai-1ã¾ã§ + Î£ Aiã‹ã‚‰å³å…¨éƒ¨ = S[i] + R[i]
// Aiç•ªç›®ã‚’ç„¡è¦–: Î£ A0_Ai-1 + Î£ Ai+1_last = S[i] + R[i+1]
endsnippet
snippet algo_range_zeta_2D "2d ruisekiwa" b
// =========================
// 2æ¬¡å…ƒã‚¼ãƒ¼ã‚¿å¤‰æ›
vector<vector<${1:long long}>> ${2:S}(${3:H} + 1, vector<$1>(${4:W} + 1));
// ã¾ãšæ¨ªå‘ãã«è¶³ã™     1 1 1 1  â†’  1 2 3 4
//                      1 1 1 1  â†’  1 2 3 4
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
// æ¬¡ã«ç¸¦å‘ãã«è¶³ã™     1 2 3 4  â†“   1 2 3 4
//                      1 2 3 4  â†“   2 4 6 8
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
// åŒ…é™¤  o o    x x    x o       x x       x o
//       o x  = x x  - x o     - o o     + o o
// from(s, t) to(x, y)
//           S[y][x] - S[y][s] - S[t][x] + S[t][s]
endsnippet
snippet algo_range_moebius "diff" b
// =========================
// ãƒ¡ãƒ“ã‚¦ã‚¹å¤‰æ›
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; ++i) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
endsnippet
snippet algo_range_imos "imos" b
// =========================
// imos
// 0 0 0 0 0 0 0 0 0        æœ«ç«¯ãŒé…åˆ—å¤–ãªã‚‰ã€æ“ä½œä¸è¦
//   |<-------->|    åŒºé–“+1
// 0 |1 0 0 0 0 0 |-1 0
// 0 |1 1 1 1 1 1 |0 0   â†after zeta
// add [l, r) = add A[l] , rev A[r]
${3:++}${1:A}[${2:l}];
if ($4 < ${6:N}) ${5:--}$1[${4:r+1}];
endsnippet
snippet algo_range_imos_2D "2d imos" b
// =========================
// 2æ¬¡å…ƒimos
// A+1  A | -1              æœ«ç«¯ãŒé…åˆ—å¤–ãªã‚‰ã€æ“ä½œä¸è¦
// A    A |
// -1ï¿£ï¿£ +1    åŒ…é™¤     then zeta
// from(s, t) to(x, y)é¢ã¸ã®åŠ ç®—
// add G[t][s], rev G[t][x + 1], rev G[y + 1][s], add G[y + 1][x + 1]
endsnippet

# =========================================================
# Sequence
# =========================================================
snippet algo_seq_merge "merge" b
// =========================
// ${1:A}ã‚’${2:B}ã«ãƒãƒ¼ã‚¸ãƒ†ã‚¯
// amortized O(logN)
// {1, 3, 4}  ->  {2}
//        {}  ,   {1, 2, 3, 4}
if ($1.size() > $2.size()) swap($1, $2);
for (auto &&v : $1) $2.${3:insert}(v);
$1.clear();
endsnippet
snippet algo_seq_zip "zip" b
// =========================
// åº§æ¨™åœ§ç¸® O(NlogN)
vector<${1:long long}> ${2:cvt} = ${3:target};
// sorté‡è¤‡å‰Šé™¤
sort($2.begin(), $2.end());
$2.erase(unique($2.begin(), $2.end()), $2.end());
// å…ƒé…åˆ—ã§ã«ã¶ãŸã‚“ã—ãŸã€idxã«å¤‰æ›ã™ã‚‹(åœ§ç¸®)
for (auto &v : $3) v = lower_bound($2.begin(), $2.end(), v) - $2.begin();
// é‡è¤‡å‰Šé™¤å¾Œã®ç¨®é¡æ•°
int ${4:sz} = $2.size();
endsnippet
snippet algo_seq_inv "seq inv" b
// =========================
// è»¢é ­æ•° O(NlogN)
// å³ã«å€’ã‚Œã‚‹A_i > A_j (i < j)ã®å›æ•°
vector<${1:long long}> ${2:cvt} = ${3:A};
// åº§æ¨™åœ§ç¸®
sort($2.begin(), $2.end());
$2.erase(unique($2.begin(), $2.end()), $2.end());
for (auto &v : $3) v = lower_bound($2.begin(), $2.end(), v) - $2.begin();
// åœ§ç¸®å¾Œã®ç¨®é¡æ•°
int ${5:sz} = $2.size();
// è¿½åŠ ã—ãªãŒã‚‰Fenwick Treeã®å³å´ã‚’è¶³ã—ä¸Šã’ã‚‹
vector<int> ${6:fwk}($5 + 1);
${7:long long} ${8:inv} = 0; // è»¢å€’æ•°
int ${9:R} = $5 - 1; // åº§æ¨™åœ§ç¸®ã—ãŸãŸã‚æœ€å¤§è¦ç´  = ã‚µã‚¤ã‚º-1
for (int i = 0; i < ${10:N}; ++i) {
	// å…¨åŒºé–“
	for (int f = $9 + 1; f; f -= f & -f) $8 += $6[f];
	// ä»Šã®æ•°ä»¥ä¸‹ã®å€‹æ•°ã‚’å¼•ã
	// ä»Šã‚ˆã‚Šå·¦å´ã®æ•°åˆ—ã§ã€ä»Šã®æ•°ã€Œã‚ˆã‚Šå¤§ãã„ã‚‚ã®ã€ã®å€‹æ•°ã‚’æ•°ãˆã‚‹
	for (int f = $3[i] + 1; f; f -= f & -f) $8 -= $6[f];
	// ä»Šã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ+1
	for (int f = $3[i] + 1; f <= $5; f += f & -f) ++$6[f];
}
endsnippet

# =========================================================
# Fenwick
# =========================================================
snippet algo_fwk "fwk" b
// =========================
// Fenwick Tree O(logN)
// 1-indexedãªã®ã§æ³¨æ„ã™ã‚‹
vector<${1:int}> ${2:fwk}(${3:sz+1});
endsnippet
snippet algo_fwk_build "fwk build" b
// =========================
// Fenwick Treeã‚’é…åˆ—$4ã§ãƒ“ãƒ«ãƒ‰ã™ã‚‹
for (int i = 1, f = i + (i & -i); i <= ${1:N}; ++i, f = i + (i & -i)) {
	${2:fwk}[i] ${3:+}= ${4:A}[i - 1];
	if (f <= $1) $2[f] $3= $2[i];
}
endsnippet
snippet algo_fwk_act "fwk act" b
// =========================
// Fenwick Tree 1ç‚¹æ›´æ–°
for (int ${1:f} = ${2:1-idx}; $1 <= ${3:fwk-size}; $1 += $1 & -$1) ${4:fwk}[$1] ${5:+}= ${6:act_value};
endsnippet
snippet algo_fwk_get "fwk get" b
// =========================
// Fenwick Tree åŒºé–“å–å¾—  çµæœã‚’$3ã«å€¤ã‚’å…¥ã‚Œã‚‹
for (int ${1:f} = ${2:1-idx}; $1; $1 -= $1 & -$1) ${3:ans} ${4:+}= ${5:fwk}[$1];
endsnippet

# =========================================================
# BFS
# =========================================================
snippet algo_bfs "bfs" b
// =========================
// å˜ä¸€å§‹ç‚¹BFS O(N+M)
queue<int> q;
vector<int> dis(${1:N}, -1);
// å§‹ç‚¹ã‚’ã‚»ãƒƒãƒˆ
q.push(${2:0});
dis[$2] = 0;
//            0
//        â†™ï¸ â†™ï¸ â†“
//     1   1  1     ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
//   â†™ï¸   â†™ï¸ â†“  â†“ â†˜ï¸
// 2   2   2  2  2
while (!q.empty()) {
	int v = q.front();
	q.pop();
	// é€£çµé ‚ç‚¹ã¸
	for (auto &&nv : ${3:G}[v]) {
		// åˆè¨ªå•ã®ã¿
		if (dis[nv] == -1) {
			// è·é›¢+1
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_multi_start "bfs multi start" b
// =========================
// è¤‡æ•°å§‹ç‚¹BFS O(N+M)
queue<int> q;
vector<int> dis(${1:N}, -1);
// è¤‡æ•°ã®å§‹ç‚¹ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
for (int i = 0; i < ${2:K}; ++i) {
	q.push(${3:C[i]});
	dis[$3] = 0;
}
//            0   0   ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
//        â†™ï¸ â†™ï¸ â†“ â†™ï¸ â†“ â†˜ï¸
//     1   1  1   1  1
//   â†™ï¸   â†™ï¸ â†“  â†“ â†˜ï¸ â†“  â†“
// 2   2   2  2  2   2
while (!q.empty()) {
	int v = q.front();
	q.pop();
	// é€£çµé ‚ç‚¹ã¸
	for (auto &&nv : ${4:G}[v]) {
		// åˆè¨ªå•ã®ã¿
		if (dis[nv] == -1) {
			// è·é›¢+1
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_grid "bfs grid" b
// =========================
// å˜ä¸€å§‹ç‚¹ã‚°ãƒªãƒƒãƒ‰BFS O(N+M)
queue<pair<int, int>> q;
// å§‹ç‚¹ã®åº§æ¨™
q.push({${1:sy}, ${2:sx}});
vector<vector<int>> dis(${3:H}, vector<int>(${4:W}, -1));
// å§‹ç‚¹ã¯è·é›¢0
dis[$1][$2] = 0;
while (!q.empty()) {
	// ä»Šã®ç‚¹ã®åº§æ¨™
	auto [py, px] = q.front();
	q.pop();
	// 4æ–¹ã‚°ãƒªãƒƒãƒ‰ã¸ã™ã™ã‚€
	for (int i = 0; i < 4; ++i) {
		int y = py + dy[i], x = px + dx[i];
		//
		// é ˜åŸŸå¤–ãªã‚‰ç„¡è¦–
		if (y < 0 or x < 0 or $3 <= y or $4 <= x) continue;
		//
		// åˆè¨ªå•ã‹ã¤ã€è¡Œã‘ã‚‹ãƒã‚¹ã§ã‚ã‚Œã°
		if (dis[y][x] == -1 and cango(${5:G}[y][x])) {
			// è·é›¢+1
			dis[y][x] = dis[py][px] + 1;
			q.push({y, x});
		}
	}
}
endsnippet
snippet algo_grid_dydx "dydx" b
// =========================
int y = ${1:i}, x = ${2:j}; // å§‹ç‚¹ã¨ã™ã‚‹
y += dy[${3:d}], x += dx[$3]; // ãƒã‚¹ç§»å‹•ã™ã‚‹
endsnippet
snippet algo_grid_filter "bfs grid filter" b
// =========================
// é ˜åŸŸå¤–
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:col} <= $2) ${5:continue};
endsnippet
snippet algo_grid_cango "grid cango" b
// =========================
// é€²ã‚ã‚‹ã‹åˆ¤å®šã™ã‚‹é–¢æ•°
auto cango = [](const char &a) -> bool {
	string white = "${1:.SG}";
	return white.find(a) != string::npos;
};
endsnippet
snippet algo_grid_toguro "toguro" b
// =========================
// ã‚°ãƒªãƒƒãƒ‰ã‚’ã¨ãã‚çŠ¶ã«é€²ã‚€
//   _______
//   _____  |
//  |   __| |
//  |_______|
//
// å§‹ç‚¹ã€æ–¹å‘d
int y = 0, x = 0, d = 0; // GRID_dydxã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨å¯¾å¿œ
for
y += dy[d], x += dx[d]; // dæ–¹å‘ã«é€²ã‚€
// é ˜åŸŸå¤–ã€ã¾ãŸã¯é€²ã‚ãªã„ãƒã‚¹ã®å ´åˆ
if (y < 0 or x < 0 or ${1:row} <= y or ${2:col} <= x or G[y][x] != -1) {
	y -= dy[d], x -= dx[d]; // ã‚„ã£ã±æˆ»ã£ã¦
	++d, d %= 4; // æ–¹å‘å¤‰ãˆã¦
	y += dy[d], x += dx[d]; // é€²ã¿ç›´ã™
}
endsnippet
snippet algo_grid_bingo "bingo" b
// =========================
// ç¸¦æ¨ªãƒŠãƒŠãƒ¡ã«ã€ãã‚ã£ã¦ã„ã‚‹ã‹åˆ¤å®š
// O(N^2)
// x|o|x   x x x   o x x
// x|o|x   o o o   x o x
// x|o|x   x x x   x x o
vector<int> cx(${1:N}); // ã‚¯ãƒ­ã‚¹1
iota(cx.begin(), cx.end(), 0);
//
vector<int> cy = cx; // ã‚¯ãƒ­ã‚¹2
reverse(cy.begin(), cy.end());
//
bool c1 = true, c2 = true;
//
// ç¢ºèªã™ã‚‹å€¤
${2:int} check_val = ${3:-1};
//
for (int i = 0; i < $1; ++i) {
	// ãƒŠãƒŠãƒ¡ã‚’åˆ¤å®š
	// o x x
	// x o x
	// x x o
	c1 &= ${4:A}[i][cx[i]] == check_val; // å·¦ä¸Šã‹ã‚‰å³ä¸‹ã«allmatch
	c2 &= $4[i][cy[i]] == check_val; // å³ä¸Šã‹ã‚‰å·¦ä¸‹ã«allmatch
	//
	// ç¸¦æ¨ªã‚’åˆ¤å®š
	bool alma = true, alma2 = true;
	for (int j = 0; j < $1; ++j) {
		// x x x
		// o o o  ã‚ˆã“
		alma &= $4[i][j] == check_val; // è¡Œå†…ã§allmatch
		// o x x
		// o x x
		// o x x  ãŸã¦
		alma2 &= $4[j][i] == check_val; // åˆ—å†…ã§allmatch
	}
	//
	// alma = iè¡Œç›®ã®ã‚ˆã“ãŒãƒ“ãƒ³ã‚´
	// alma2= iåˆ—ç›®ã®ç¸¦ãŒãƒ“ãƒ³ã‚´
	if (alma or alma2) {
		cout << "row col allmatch" << endl;
	}
}
// c1 = ã‚¯ãƒ­ã‚¹1ãŒãƒ“ãƒ³ã‚´
// c2 = ã‚¯ãƒ­ã‚¹2ãŒãƒ“ãƒ³ã‚´
if (c1 or c2) {
	cout << "cross allmatch" << endl;
}
endsnippet

# =========================================================
# DFS
# =========================================================
snippet algo_dfs "dfs" b
// =========================
// DFS O(N+M)
//         o
//       â†™ï¸â†—ï¸  â†˜ï¸
//      o      A
//   â†™ï¸â†—ï¸ â†˜ï¸â†–ï¸   è¡Œ â†˜ï¸ â†–ï¸ å¸°
//  o    o        B
//
// è¡ŒããŒã‘: Aâ†’Bã«æ¥ãŸã‚ã¨ã€‚ ä»Šã®é ‚ç‚¹=å¼•æ•°v=B
// å¸°ã‚ŠãŒã‘: Bâ†’Aã«æˆ»ã‚‹å‰ã€‚ä»Šã®é ‚ç‚¹=å¼•æ•°v=B
vector<bool> seen(${1:N}, false);
auto dfs = [&](auto &f, int v) -> void {
	// è¡ŒããŒã‘
	seen[v] = true;
	for (auto &&nv : ${2:G}[v]) {
		if (seen[nv]) continue;
		f(f, nv);
	}
	// å¸°ã‚ŠãŒã‘
};
dfs(dfs, ${3:0});
endsnippet
snippet algo_dfs_tree "dfs" b
// =========================
// æœ¨ã®æ·±ã•DFS O(N+M)     depth
//         o           ---- 0
//       â†™ï¸â†—ï¸  â†˜ï¸
//      o      A       ---- 1
//   â†™ï¸â†—ï¸ â†˜ï¸â†–ï¸   è¡Œ â†˜ï¸ â†–ï¸ å¸°
//  o    o        B    ---- 2
//
// è¡ŒããŒã‘: Aâ†’Bã«æ¥ãŸã‚ã¨ã€‚ ä»Šã®é ‚ç‚¹=å¼•æ•°v=B
// å¸°ã‚ŠãŒã‘: Bâ†’Aã«æˆ»ã‚‹å‰ã€‚ä»Šã®é ‚ç‚¹=å¼•æ•°v=B
vector<int> depth(N);
auto dfs = [&](auto &f, int v, int p, int d) -> void {
	// è¡ŒããŒã‘
	depth[v] = d;
	for (int nv : ${1:G}[v]) {
		if (nv == p) continue; // è¦ªã¸æˆ»ã‚‰ãªã„
		f(f, nv, v, d + 1);
	}
	// å¸°ã‚ŠãŒã‘
};
dfs(dfs, ${2:root}, -1, 0); // è¦ªãªã—
endsnippet

# =========================================================
# DP
# =========================================================
snippet algo_dp "dp" b
// =========================
// æˆæœç‰©ã®æ™‚é–“é †ãªçŠ¶æ…‹ç®¡ç†
// iç•ªç›®ã®è¡Œã§ã®${1:M}å€‹ã®çŠ¶æ…‹
// 0 0 0 0 0
//   â†˜ï¸ â†“
// X X ? X X
${2:vector<int>} ${3:def}($1+1, ${4:INF});
auto dp = $3, nx = dp; // ä»Šè¡Œã‚’dpã€æ¬¡è¡Œã‚’nx
algo_dp_ini
endsnippet
snippet algo_dp_ini "dp ini" b
// =========================
// çŠ¶æ…‹0ã§ã® ã‚³ã‚¹ãƒˆ | é€šã‚Šæ•°
dp[${1:0}] = ${2:0};
algo_dp_for
endsnippet
snippet algo_dp_for "dp for" b
// =========================
// ç¸¦å‘ãã«ãƒ«ãƒ¼ãƒ—
// â†“ | 0 0 0 0 0
// â†“ |   â†˜ï¸ â†“
// â†“ | X X ? X X
for (int i = 0; i < ${1:N}; ++i, swap(dp, nx)) {
	// ä»Šè¡Œã‚’æ¬¡è¡Œã«é·ç§»ã—ã€è¡Œã‚’åŸ‹ã‚ã‚‹
	// - é¸ã°ãªã„: dp    ç·©å’Œã€é€šã‚Šæ•°
	// - å¿…ãšé¸ã¶: def   åˆæœŸåŒ–ã™ã‚‹
	nx = ${2:dp def};
	// æ¼¸åŒ–å¼éƒ¨åˆ†
	${3}
}
// æœ€çµ‚è¡Œã¯dp
endsnippet
snippet algo_dp_add "dp add" b
// =========================
// dp_j  dp_$1
//     â†˜ï¸  â†“    åŠ ç®—
// nx_j  nx_$1
nx[${1:j + 1}] += dp[${2:j}];
endsnippet
snippet algo_dp_chdp "chdp knapsack" b
// =========================
// dp_from   dp (nx=dpã§ç·©å’Œæ¸ˆã¿)
//    +cost â†˜ï¸  â†“
//          nx_to
nx[${3:to}] = ${1:min}(nx[$3], dp[${2:from}] + ${4:cost});
endsnippet
snippet algo_dp_seg "dp seg" b
// =========================
SegTree<${1:Mmin}<${2:long long}>> ${3:dp}(${4:åŒºé–“é•·} + 1);
$3.set(${5:0}, ${6:åˆæœŸã‚³ã‚¹ãƒˆ});
endsnippet
snippet algo_dp_chdp_seg "chdp seg" b
// =========================
// | dp_l  dp_l+1  ... dp_r-1 | dp_r  ...
//      â†˜ï¸ â†˜ï¸ â†“ â†“ â†™ï¸ â†™ï¸  åŒºé–“å–å¾—+cost
//         dp_to   ã¨ç·©å’Œ
${1:dp}.set(${4:to}, ${2:min}($1[$4], $1.get(${3:from l, r}) + ${5:cost}));
endsnippet

# TODO é·ç§»å¼ãƒ¡ã‚¤ãƒ³ã«ä¿®æ­£ä¸­

snippet algo_dp_knapsack_alt "dp knapsack alt" b
// TODO ã“ã‚Œç†è§£ã—ãŸã‚‰æ±ç”¨åŒ–ã—ãŸã„ã­
int ${1:V} = ${2:1e5};
vector<vector<${3:int}>> dp(${4:N} + 1, vector<$3>($1 + 1, inf<$3>));
dp[0][0] = 0;
for (int i = 0; i < $4; ++i) {
	for (int j = 0; j <= $1; ++j) {
		dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
		if (v[i] <= j) {
			dp[i + 1][j] = min(dp[i + 1][j], dp[i][j - ${5:v}[i]] + ${6:w}[i]);
		}
	}
}
$3 ans = 0;
for (int i = 0; i <= $1; ++i) {
	if (dp[$4][i] <= ${7:W}) {
		ans = max(ans, i);
	}
}
cout << ans << endl;
endsnippet

snippet algo_dp_lcs "dp lcs" b
// WIP ã“ã‚Œã¯é•·ã•ã ã‘ã€‚æœ¬ä½“ã‚’æ±‚ã‚ã‚‹ã‚‚ã®ã‚‚ã‚ã‚‹
// LCS
int ${3:s} = ${1:S}.size(), ${4:t} = ${2:T}.size();
vector<vector<int>> dp($3 + 1, vector<int>($4 + 1, 0));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		dp[i + 1][j + 1] = max(
			{dp[i][j + 1], dp[i + 1][j], dp[i][j] + ($1[i] == $2[j])});
	}
}
cout << dp[$3][$4] << endl;
endsnippet
snippet algo_dp_lis "dp lis" b
// WIP
// LIS
endsnippet
snippet algo_dp_order "dp order" b
// WIP
// æ¡DP
endsnippet
snippet algo_dp_range "dp range" b
// WIP
// åŒºé–“DP
endsnippet
snippet algo_dp_bit "dp bit" b
// WIP
// bité›†åˆDP
endsnippet
snippet algo_dp_tree "dp tree" b
// TODO
// é ‚ç‚¹vã®éƒ¨åˆ†æœ¨ã‚’å¯¾è±¡ã¨ã—ãŸæœ¨DP
vector<${1:long long}> dp(${2:N}, ${3:0});
auto dfs = [&](auto &f, int v, int par = -1) -> void {
	if (${4:tree}[v].size() == 1) {
		dp[v] = 0;
		return;
	}
	$1 tmp = 0;
	for (auto &&[from, to, cost, id] : $4[v]) {
		if (to == par) continue;
		f(f, to, from);
		tmp = ${5:max}(tmp, dp[to] + cost);
	}
	dp[v] = tmp;
};
dfs(dfs, N);
cout << dp[N - 1] << endl;
endsnippet
snippet algo_dp_rerooting "dp rerooting" b
// WIP
// å…¨æ–¹ä½æœ¨DP
endsnippet
snippet algo_dp_doubling "doubling" b
// =========================
// ãƒ€ãƒ–ãƒªãƒ³ã‚°
long long log = 1;
while ((1ll << log) <= K) log++;
// =========================
// dp[i][j] := 2^i å›ã§è¡Œãã¨ã“ã‚ã€jç¨®é¡
vector<vector<long long>> dp(log, vector<long long>(${1:N}));
for (int i = 0; i < N; ++i) {
	dp[0][i] = ${2:A}[i];
}
// =========================
// å‰è¨ˆç®— ~2å›æ¬¡ã¸ã®é·ç§»~
//   j dp0  dp1  dp2  ...  dp_last
// i
// 0             dp[i][j] 1å€‹æ¬¡ãŒã‚ã‚‹ã®ã§
// 1       dp[i][j] â†²  ã“ã“ã«è¡ŒããŸã„
// ...
// â—½ï¸1å›æ¬¡(æ™®é€šã®DP)ã®é·ç§»ã¯
//       æ¬¡è¡Œ[j] = ä»Šè¡Œ[j]
//    dp[i + 1][j] = dp[i][j]
// dp[i][j] ã¯2^iã§è¡Œã£ãŸæ™‚ã®ä½•ç¨®é¡ç›®ã‹ã€ãªã®ã§
// â—½ï¸2å›æ¬¡ã¯
//     2å›æ¬¡[j] = ä»Šè¡Œ[ 1å›æ¬¡ã®j ]
//   dp[i + 1][j] = dp[i][ dp[i][j] ]
// =========================
for (int i = 0; i < log - 1; ++i) {
	for (int j = 0; j < N; j++) {
		// æ¼¸åŒ–å¼
		// choose
		dp[i + 1][j] = dp[i][dp[i][j]];
		// dp[i + 1][j] = dp[i][j] + dp[i][(j + dp[i][j]) % N];
	}
}
// =========================
// ã‚¯ã‚¨ãƒª
long long ans = 0;
for (int i = 0; K > 0; ++i) {
	// choose
	if (K & 1) ans = dp[i][ans];
	// if (K & 1) ans += dp[i][ans % N];
	K >>= 1;
}
cout << ans << endl;
endsnippet

# =========================================================
# Food for thought
# =========================================================
snippet serna37 "food for thought (cheat sheet) preview only" bi
### ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆ (ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ã¿)
[ â˜ ï¸  ãƒã‚°ç‹©ã‚Šå…¸å‹ ]
- æ›ã‘ç®—          :æº¢ã‚Œãªã„ã‚ˆã†å‰²ã‚‹
- å¼•ãç®—          :å‰²ã‚Šç®—
- èª¤å·®            :A < Bã¯A < B - EPS
- é…åˆ—å¤–å‚ç…§      :æœ€å°ãŒ0ä»¥ä¸‹ã€æœ€å¤§ãŒN-1
- 0é™¤ç®—           :å‰²ã‚‹æ•°ãŒ0ã«ãªã‚‹ã‹è€ƒæ…®
- ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼  :long longã«ã—ãªã•ã„
- ã‚³ãƒ¼ãƒŠãƒ¼ã‚±ãƒ¼ã‚¹  :0ã®ã¨ãã€1ã®ã¨ãã€æœ«ç«¯
- å˜˜è²ªæ¬²          :æ¼¸åŒ–å¼ãŒã§ãã‚‹ãªã‚‰DP
- DPåˆæœŸåŒ–å¿˜ã‚Œã€ãƒ«ãƒ¼ãƒ—ç¯„å›²ä¸è¶³ã¯ãªã„ã‹ï¼Ÿ
- â—¯å€‹ã®ã¯ãšã€ã¯ã‚„ã‚ã¦æ˜ç¢ºãªæ¡ä»¶ã¾ã§æ„šç›´ãƒ«ãƒ¼ãƒ—

[ âš™ï¸  æ¢ç´¢ç©ºé–“ ]
- å…¨åŸŸã§æ¢ç´¢ã€€ç·šå½¢ãªã‚‰é–“ã«åˆã†
- ç­”ãˆã®å€™è£œã‚’æ¢ç´¢
- ç­”ãˆã«å¯„ä¸ã™ã‚‹éƒ¨åˆ†ã‚’è€ƒæ…®
- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç‰‡æ–¹å›ºå®šã™ã‚‹
- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿3ã¤ã®æ™‚ã¯çœŸã‚“ä¸­ã‚’å›ºå®šã™ã‚‹
- Nå€ãšã¤ãƒ«ãƒ¼ãƒ—ã€â—¯ ä¹—é™ç•Œã§ãƒ«ãƒ¼ãƒ—

[ ğŸ”¥ æ€§è³ªãƒ»å‰è¨ˆç®—ãƒ»é«˜é€ŸåŒ– ]
- äºŒåˆ†æ¢ç´¢: ç­”ãˆã®å€™è£œã«å˜èª¿æ€§ã€å°ã•ã„æ–¹ã‹ã‚‰Kç•ªç›®
- ç´¯ç©å’Œ
- åŒ…é™¤åŸç†
- ãƒ€ãƒ–ãƒªãƒ³ã‚°: å¤§ãã„Kå€‹æ¬¡
- åŒºé–“ã‚¯ã‚¨ãƒª
  - idxã‚’ç®¡ç†ã—äºŒåˆ†æ¢ç´¢
  - ã‚»ã‚°æœ¨ ãƒ¢ãƒã‚¤ãƒ‰ã‚’æ”¹é€ 
- å¼å¤‰å½¢: æ·»ãˆå­—ã‚’æƒãˆã‚‹ã€€A_i + i = A_j + j
  - i < jã§ã€Œã‚ˆã‚Šå°ã•ã„ã€ä»Šã¾ã§ã®å€¤ã‹ã‚‰æ•°ãˆä¸Šã’
    â†’ å˜èª¿æ€§ãŒã‚ã‚‹: äºŒåˆ†æ¢ç´¢
	â†’ å˜èª¿æ€§ãŒãªã„: åœ§ç¸®Fenwick
      â†’ è¨ˆä¸Šã—ã¦ã‹ã‚‰vec mapã«è¿½åŠ 
- ãã®ä»–
  - ãƒ‘ãƒªãƒ†ã‚£ã§åˆ†ã‘ã‚‹
  - å¯¾å¶ã‚’è¨ˆç®—ã—ã¦å¼•ã
  - æ¥µç«¯ãªå ´åˆã‚’è€ƒãˆã¦ã¿ã‚‹
  - ä¸»å®¢è»¢å€’ã€€é…åˆ—ã€æ™‚é–“ã‚’é€†å‘ãã«è¨ˆä¸Š
  - åŒæ–¹å‘ãƒªã‚¹ãƒˆã¯map2å€‹
- åˆ¶ç´„ãƒ¡ã‚¿
  - åˆ¶ç´„ãŒæŒ‡æ•°æ™‚é–“ã‚’è¨±ã™â†’ åŠ›æŠ€ã‚’ã¾ãšå…ˆã«
  - åˆ¶ç´„ãŒç·šå½¢ã‚®ãƒªã™ãã‚‹æœ€é©åŒ–â†’ DPã¯è²ªæ¬²ã‹ã‚‚
endsnippet

