# =========================================================
# DP
# - base
# TODO swapã§3æ¬¡å…ƒã¨ã‹ã«å¯¾å¿œã§ãã‚‹ï¼Ÿ
# - Knapsack
# - XXX LCS
# - XXX LIS
# - XXX æ¡DP
# - XXX åŒºé–“DP
# - XXX bitDP
# - XXX æœ¨DP
# - XXX å…¨æ–¹ä½æœ¨DP
# - XXX ãƒ€ãƒ–ãƒªãƒ³ã‚°
# =========================================================

snippet algo_dp_cheat "dpã®ãƒ’ãƒ³ãƒˆ" b
// - ãã®æ•°ã‚’ä½œã‚Œã‚‹ã‹: éƒ¨åˆ†å’Œ
//   (def) dp_ij := iå€‹ç›®ã¾ã§ã§ã€jã‚’ä½œã‚Œã‚‹å ´åˆtrue
//   (trn) nx = dp, if (dp[j]) nx[j + X] = true;
// - é€£ç¶šã§é¸ã°ãªã„: Vacation
// - åŒºé–“ã‚¯ã‚¨ãƒªã‚’è²°ã†DP: zeta, seg
endsnippet

snippet algo_dp "dp" b
// =====================================

// â­ï¸ DPãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
// å‹: ${1:long long}
// é·ç§»å›æ•°: ${2:N}
// 2æ¬¡å…ƒè¡¨ã®å ´åˆã€æ¨ªã®é•·ã•: ${3:M} : ç•ªå…µ+1 sizeã‚‚+1
// è¡¨å…¨ä½“ã®åˆæœŸå€¤: ${4:INF}
// dp[0]æœ€åˆã®å€¤: ${5:0 1} : é€šã‚Šæ•°=1, æœ€é©åŒ–=0

// =====================================
//1æ¬¡å…ƒDP â†±    â†´    â†´
//dp_i  dp_i+1  dp_i+2
//vector<$1> dp($2, $4); dp[0] = $5;
//for (int i = 0; i < $2; ++i) {
//	for (int j = 1; j <= K; ++j) { // frog K
//		if (i + j < N) {
//			dp[i + j] = min(dp[i + j], dp[i] + cost);
//		}
//	}
//}

// =====================================
/* DP */
vector<$1> def($3, $4); // 2æ¬¡å…ƒDP swap
auto dp = def, nx = dp; dp[0] = $5;
for (int i = 0; i < $2; ++i, swap(dp, nx)) {
	// â­ï¸ å‰è¡Œã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‹ã©ã†ã‹
	// - é¸ã°ãªã„: dp    ç·©å’Œã€é€šã‚Šæ•°
	// - å¿…ãšé¸ã¶: def   åˆæœŸåŒ–ã™ã‚‹
	nx = dp;
	//nx = def;

	// ...  dp_j                  ...
	//            â†˜
	// ...  nx_j  nx_j+X  nx_i+2  ...
	// â­ï¸ æ¨ªå‘ããƒ«ãƒ¼ãƒ—
	for (int j = 0; j < $3; ++j) {
		//nx[j + X] = min(nx[j + X], dp[j] + cost);
		//nx[i + X] += dp[i];
	}

	// â­ï¸ å‰ã®å‘¨ã®å’Œã‚’åˆ©ç”¨ã™ã‚‹ãªã‚‰ç´¯ç©å’Œ
	// dp_j  dp_j+1  dp_j+2
	//        â†˜       â†˜       â†˜
	//                   nx_j
	// S := zeta dp
	//for (int j = AA; j <= BB; ++j) {
	//	nx[j] += S[j + 1];
	//}

}

// =====================================
// ğŸ”¥æœ€å¾Œã®å€¤
//cout << dp.back() << endl;
//cout << (dp.back() == INF ? -1 : dp.back()) << endl;

// ğŸ”¥min max
//cout << *max_element(dp.begin(), dp.end()) << endl;
//cout << *min_element(dp.begin(), dp.end()) << endl;

// ğŸ”¥mod sum
//long long ans = 0;
//for (auto &&v : dp) ans += v, ans %= MOD;
//cout << ans << endl;
endsnippet

snippet algo_dp_seg "DP on segment tree" b
// =====================================
// â­ï¸ DPãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
// å‹: ${1:long long}
// é·ç§»å›æ•°: ${2:N}
// 2æ¬¡å…ƒè¡¨ã®å ´åˆã€æ¨ªã®é•·ã•: ${3:L+1} : ç•ªå…µ+1 sizeã‚‚+1
// è¡¨å…¨ä½“ã®åˆæœŸå€¤: ${4:INF}
// dp[0]æœ€åˆã®å€¤: ${5:0 1} : é€šã‚Šæ•°=1, æœ€é©åŒ–=0

// ã‚»ã‚°æœ¨DP
algo_ds_segment_tree_ALL
act(0, $5);
for (int i = 0; i < $2; ++i) {
	$1 tmp = prod(l, r + 1);
	act(X, tmp + cost); // æ›´æ–°ã‹ç·©å’Œ
}
//cout << at(L) << endl;
//cout << seg[L + sz] << endl;
//cout << seg[1] << endl;
endsnippet




# TODO é·ç§»å¼ãƒ¡ã‚¤ãƒ³ã«ä¿®æ­£ä¸­

snippet algo_dp_knapsack_alt "dp knapsack alt" b
// TODO ã“ã‚Œç†è§£ã—ãŸã‚‰æ±ç”¨åŒ–ã—ãŸã„ã­
int ${1:V} = ${2:1e5};
vector<vector<${3:int}>> dp(${4:N} + 1, vector<$3>($1 + 1, inf<$3>));
dp[0][0] = 0;
for (int i = 0; i < $4; ++i) {
	for (int j = 0; j <= $1; ++j) {
		dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
		if (v[i] <= j) {
			dp[i + 1][j] = min(dp[i + 1][j], dp[i][j - ${5:v}[i]] + ${6:w}[i]);
		}
	}
}
$3 ans = 0;
for (int i = 0; i <= $1; ++i) {
	if (dp[$4][i] <= ${7:W}) {
		ans = max(ans, i);
	}
}
cout << ans << endl;
endsnippet

snippet algo_dp_lcs "dp lcs" b
// WIP ã“ã‚Œã¯é•·ã•ã ã‘ã€‚æœ¬ä½“ã‚’æ±‚ã‚ã‚‹ã‚‚ã®ã‚‚ã‚ã‚‹
// LCS
int ${3:s} = ${1:S}.size(), ${4:t} = ${2:T}.size();
vector<vector<int>> dp($3 + 1, vector<int>($4 + 1, 0));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		dp[i + 1][j + 1] = max(
			{dp[i][j + 1], dp[i + 1][j], dp[i][j] + ($1[i] == $2[j])});
	}
}
cout << dp[$3][$4] << endl;
endsnippet
snippet algo_dp_lis "dp lis" b
// WIP
// LIS
endsnippet
snippet algo_dp_order "dp order" b
// WIP
// æ¡DP
endsnippet
snippet algo_dp_range "dp range" b
// WIP
// åŒºé–“DP
endsnippet
snippet algo_dp_bit "dp bit" b
// WIP
// bité›†åˆDP
endsnippet
snippet algo_dp_tree "dp tree" b
// TODO
// é ‚ç‚¹vã®éƒ¨åˆ†æœ¨ã‚’å¯¾è±¡ã¨ã—ãŸæœ¨DP
vector<${1:long long}> dp(${2:N}, ${3:0});
auto dfs = [&](auto &f, int v, int par = -1) -> void {
	if (${4:tree}[v].size() == 1) {
		dp[v] = 0;
		return;
	}
	$1 tmp = 0;
	for (auto &&[from, to, cost, id] : $4[v]) {
		if (to == par) continue;
		f(f, to, from);
		tmp = ${5:max}(tmp, dp[to] + cost);
	}
	dp[v] = tmp;
};
dfs(dfs, N);
cout << dp[N - 1] << endl;
endsnippet
snippet algo_dp_rerooting "dp rerooting" b
// WIP
// å…¨æ–¹ä½æœ¨DP
endsnippet
snippet algo_dp_doubling "doubling" b
// ãƒ€ãƒ–ãƒªãƒ³ã‚°
long long log = 1;
while ((1ll << log) <= K) log++;
// =========================
// dp[i][j] := 2^i å›ã§è¡Œãã¨ã“ã‚ã€jç¨®é¡
vector<vector<long long>> dp(log, vector<long long>(${1:N}));
for (int i = 0; i < N; ++i) {
	dp[0][i] = ${2:A}[i];
}
// =========================
// å‰è¨ˆç®— ~2å›æ¬¡ã¸ã®é·ç§»~
//   j dp0  dp1  dp2  ...  dp_last
// i
// 0             dp[i][j] 1å€‹æ¬¡ãŒã‚ã‚‹ã®ã§
// 1       dp[i][j] â†²  ã“ã“ã«è¡ŒããŸã„
// ...
// â—½ï¸1å›æ¬¡(æ™®é€šã®DP)ã®é·ç§»ã¯
//       æ¬¡è¡Œ[j] = ä»Šè¡Œ[j]
//    dp[i + 1][j] = dp[i][j]
// dp[i][j] ã¯2^iã§è¡Œã£ãŸæ™‚ã®ä½•ç¨®é¡ç›®ã‹ã€ãªã®ã§
// â—½ï¸2å›æ¬¡ã¯
//     2å›æ¬¡[j] = ä»Šè¡Œ[ 1å›æ¬¡ã®j ]
//   dp[i + 1][j] = dp[i][ dp[i][j] ]
// =========================
for (int i = 0; i < log - 1; ++i) {
	for (int j = 0; j < N; j++) {
		// æ¼¸åŒ–å¼
		// choose
		dp[i + 1][j] = dp[i][dp[i][j]];
		// dp[i + 1][j] = dp[i][j] + dp[i][(j + dp[i][j]) % N];
	}
}
// =========================
// ã‚¯ã‚¨ãƒª
long long ans = 0;
for (int i = 0; K > 0; ++i) {
	// choose
	if (K & 1) ans = dp[i][ans];
	// if (K & 1) ans += dp[i][ans % N];
	K >>= 1;
}
cout << ans << endl;
endsnippet

